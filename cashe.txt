В моём примере базы есть пользователи, которые покупают лотерейные билеты (place, если что - номер этого билета,
просто подразумевал такие лотереи, где ты можешь сам выбрать ячейку, к примеру 5374 из 10000).
Соответственно, т.к. лотереи происходят в определённый этап, а все лотерейные билеты сгорают после очередного розыгрыша,
то кэш нам пригодится для хранения последних купленных билетов. Если информация о билете будет обновлена,
перезаписываем его в кэш. Т.к. кэш, возможно, не сможет хранить все билеты одновременно, то можно хранить в нем только те,
к которым обращение (создание-покупка или обновление) было недавно, и вытеснять те, к которым обращались давно
(при обновлении - сначала пытаемся вытеснить старый экземпляр этого билета, если он есть). 
Шардирование нам вряд ли пригодится, как и возможность хранить данные после перезагрузки приложения →
→ необходимо использовать memcahed, т.к. он и быстрее работает, и быстрее настраивается.
Если же понадобятся какие-то новые функции (те, которые описаны выше: шардирование, репликация в ходе
разработки приложения, возможность хранить данные после перезагрузки приложения и т.д.) → переходим на redis.
